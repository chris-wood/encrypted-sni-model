\documentclass[twoside]{article}

\usepackage[utf8]{inputenc}
\usepackage{comment}
\usepackage{todonotes}
\usepackage{msc5}
\usepackage{listings}
\usepackage{url}
\usepackage{tikz-qtree}
\usepackage{graphicx}
\usepackage{paralist}
\usepackage{algorithm,algorithmic}
\usepackage{amsmath, amssymb, amsthm, amsfonts, caption, stmaryrd, mathtools, syntax, mdframed}
\usepackage{cryptocode}

\newenvironment{prog}{\begin{array}[t]{@{}l@{}}}{\end{array}}

\newcommand{\adv}{{\sf Adv}}
\newcommand{\madv}{\mathsf{Adv}}
\newcommand{\CSess}{\mathcal{C}}
\newcommand{\SSess}{\mathcal{S}}
\newcommand{\laction}[2]{$\begin{array}{c}\mbox{\textrm{#1}}\\#2\end{array}$}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zp}{\mathbb{Z}_p}
\newcommand{\M}{\mathbb{M}}
\newcommand{\SIGN}{\mathsf{SIGN}}
\newcommand{\HMAC}{\mathsf{HMAC}}
\newcommand{\HKDF}{\mathsf{HKDF}}
\newcommand{\ENC}{\mathsf{ENC}}
\newcommand{\DEC}{\mathsf{DEC}}
\newcommand{\sk}[1]{\mathit{sk}_{#1}}
\newcommand{\vk}[1]{\mathit{vk}_{#1}}
\newcommand{\shared}{\mathit{shared}}
\newcommand{\const}{\mathit{const}}
\newcommand{\e}{\mathit{enc}}
\newcommand{\m}{\mathit{mac}}
\newcommand{\rk}{\mathit{rk}}
\newcommand{\ck}{\mathit{ck}}
\newcommand{\tg}{\mathit{tag}}
\def\hash#1{\mathsf{H}(#1)}
\def\sign#1#2{\mathsf{sign}^{#2}(#1)}
\def\hmac#1#2{\mathsf{HMAC\mbox{-}H}^{#2}(#1)}
\def\mac#1#2{\mathsf{mac}^{#2}(#1)}
\def\tlsmac#1#2{\mathsf{mac}_{96}(#2,#1)}
\def\aead#1#2#3{\mathsf{aead}^{#2}(#1)}
\def\aenc#1#2{\mathsf{enc}^{#2}(#1)}
\def\adec#1#2{\mathsf{dec}^{#2}(#1)}
\def\mac#1#2{\mathsf{mac}^{#2}(#1)}
\def\kdf#1{\mathsf{kdf}(#1)}
\def\kdfpair#1#2{\mathsf{kdf}(#1, #2)}
\def\kdfcontext#1#2{\mathsf{kdf}(#1,#2)}
\def\dh#1#2{\mathsf{dh}(#1,#2)}
\def\kdfi#1#2{\mathsf{kdf}_{#1}(#2)}
\def\kdfz{\mathsf{kdf}_0}
\def\hkdf#1{\mathsf{hkdf}(#1)}
\def\dlog#1{\mathsf{dlog}(#1)}
\def\factor#1{\mathsf{factor}(#1)}
\def\cert{\mathit{cert}}
\def\kex{\mathit{kex}}
\def\pk{\mathit{pk}}
\def\sk{\mathit{sk}}
\def\pkp#1{\mathit{pk}_#1}
\def\skp#1{\mathit{sk}_#1}
\def\vd#1#2{\mathsf{finished}(#2,#1)}
\def\anon{\mathtt{anon}}
\def\pms{\mathit{pms}}
\def\keys{\mathit{keys}}
\def\log{\mathit{log}}
\def\ctx{\mathit{ctx}}
\def\ms{\mathit{ms}}
\def\cvd{\mathit{cvd}}
\def\svd{\mathit{svd}}
\def\sid{\mathit{sid}}
\def\mod{\mathbin{\mathrm{mod}}}
\def\info{\mathit{info}}
\def\cfg{\mathit{cfg}}
\def\nego{\mathit{nego}}
\def\uid{\mathit{uid}}
\def\pref{\mathit{Nego}}
\def\cid{\mathit{cid}}
\def\ems{\mathit{ems}}
\def\psk{\mathit{psk}}
\def\ctx{\mathit{ctx}}
\def\hk{\mathit{hk}}
\def\dk{\mathit{dk}}
\def\ak{\mathit{ak}}
\def\sni{\mathit{sni}}
\def\ksni{g^s}
\def\ksnipriv{s}

\def\esnikey{\mathtt{'esni key'}}
\def\esniiv{\mathtt{'esni iv'}}
\def\esnibinder{\mathtt{'esni binder'}}
\def\esninonce{\mathtt{'esni nonce'}}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\title{Encrypted SNI: Privacy and Security}
\author{No Name}
\date{\today}

\begin{document}

\maketitle

\begin{comment}
# Outline
- ESNI use cases, overview, and desired security goals:
    - Use cases:
        - Name privacy (coupled with DNS) against "active" attacker (modulo traffic analysis), local service discovery
    - Operational requirements and criteria: (listed from the draft)
    - Design overview:
        - Summary of draft 4
        - Overview of related designs
    - Four security/privacy requirements:
        - ESNI privacy (requirement #2):
            1. Both endpoints agree on the context
            2. Agreement implies knowledge of SNI and key share
            3. Client has proof that server has private ESNI key
    - Passive attacker: 
        - Probabilistic public key encryption (is sufficient?)
    - Known active attacks and observations:
        - Probing (client offline, draft 4): Differences in service configurations can leak information.
        - HRR mix and match (client offline, draft 4): Attacker-chosen key share, client-chosen SNI.
        - Server reaction attack (client offline, draft 4): Use ticket and server reaction for dictionary attack.
        - Client reaction attacks (earlier draft, client online): Include nonce so that same entity which sent certificate actually processed the ESNI value.
        <!-- - HRR trial decryption (client offline): Client-chosen SNI, server-chosen key share. -->
        <!-- - PSK and ENSI (draft 4): Change CH ESNI value to be attacker-controlled, and server aborts or not based on SNI+PSK equality -->
- Basic anonymous DH model (handshake secret integrity):
    - (Challenge response with the nonce)
    - Two messages (CH, SH), and proof
    - Four messages (CH1, HRR, CH2, SH), and proof
- Handshake side channels
    - (Data about handshake message size distribution?)
    - (Application data side channels -- defer to future work?)
    - CH and SH generation functions and requirements
- Integration with TLS
    - Proxy-based transformation
    - PSK binder and key schedule injection
    - (Signalling via SH.Random or explicit SH extension)
- Implementation and experimentation
\end{comment}

\begin{comment}
# Notes
- Assume that application data transfer leaks nothing about the service.

bindings: cast in terms of contexts (transcripts)
Backward binding: integrity for ClientHello
Forward binding: 
- want to detect deletion of SNI
- proxy needs DH secrets to determine the right transcript -- can't be two entities on the client side
- could treat origin padding as a configuration
- GeneraetSH must be done at the proxy, and not based on origin servers. Can get away with unmodified servers (modulo template)
- GeneraetCH/SH are the baseline properties -- show that adding forward/backward binding keeps existing properties while giving new properties
  - These may be determined by checkboxes. If any two F's are the same, then the privacy properties hold.
  - Q: should ACME be issuing certificates of a certain length

- flipping bits in CH should cause handshake keys to differ (Kazuho's does NOT do this, and there's an oracle at the client handshake)
- always need backwards binding (for messages, but possibly based on the entire transcript?)
- kazuho: enumerate domains and trial decrypt based on all possible transcripts

What we want to hide:
- SNI value itself
- A connection negotiated ESNI
- Whether the ESNI capability
- Whether the client offered ESNI

Requirements:
1. TLS agrees on SNI (forward binding, native to TLS)
2. TLS+ESNI gives us (1) and protects SNI privacy (backward binding)
  - 1/k anonymity, without forward secrecy

Optional:
3. TLS+ESNI gives (1-2) and protects the fact that ESNI was chosen
4. TLS+ESNI (1-3), plus whether the client offered ESNI


%%% Agenda:
%** Writeup review
%** ProVerif basic model with attacks -- should the ServerHello have a signal?
%** Writeup of how Kazuho/Steven PRs satisfy the basic model
%** Game-based definition (port)
\end{comment}

\tableofcontents

\section{Introduction}

The TLS Server Name Indication extension \cite{xxx} is an increasingly important part of the TLS protocol.
Modern TLS server deployments often offer multiple certificates behind a single IP address. The SNI helps
servers choose which certificate to choose for a given connection. However, this extension also leaks the 
server name to any on-path observer. With recent pushes to encrypt DNS and protect names from such adversaries,
the SNI extension is a privacy problem for clients. The Encrypted SNI extension \cite{ietf-tls-esni-04} attempts
to address this privacy problem by encrypting the SNI in transit. However, to date, asserting correctness and
privacy properties of the protocol proved difficult. 

\textbf{Formal Analysis.} \todo[inline]{writeme}

\textbf{Contributions.} \todo[inline]{writeme}

\section{Encrypted SNI Overview}

%% XXX: misconfigurations where use of public name goes to a server that does not negotiate ESNI but does offer a certificate that terminates to the public name
%% XXX: draw figures of deployment scenarios

Encrypted SNI is a tool for hiding server names from network connections. There are several operational goals 
for Encrypted SNI \cite{requirements}, described below:
%
\begin{compactitem}
  \item Avoid widely-deployed shared secrets: One approach to the problem would be for all
  clients and servers to share a secret that encrypts (and decrypts) the SNI. However, any 
  client in this set of trusted peers could then decrypt the SNI of others. Moreover, compromise
  of any node in possession of the secret puts all members at risk. Thus, ESNI requires 
  public key encryption.
  \item Work with non-ESNI servers to avoid fallback: Without the need for fallback, ESNI 
  is a simple ECIES-like protocol, wherein the SNI is encrypted under a public key of the 
  service provider.
  \item Do not introduce extra round trips: Encrypting the SNI must not come at the cost of 
  extra round trips. For example, one possible approach is to SNI-based certificate authentication
  at the application protocol layer, e.g., using HTTP/2 Secondary Certificates \cite{xxx}, after
  the TLS connection finishes and is authenticated with a ``public name.'' While this may work,
  the extra latency cost may be prohibitively expensive for certain clients.
  \item Forward secrecy: Ideally, SNI encryption would have some amount of forward secrecy.
  However, as SNI encryption cannot introduce additional round trips, forward secrecy is not
  possible using public key encryption primitives such as ECIES \cite{XXX} or HPKE \cite{XXX}
  \item Prevent SNI-based DoS attacks: A consequence of using public key encryption is that
  servers must perform a public key operation without having validated the client. HelloRetryRequests
  may help dampen the effects of DoS attacks, though these come at the cost of introducing
  additional complexity into the protocol. See Section \ref{sec:security} for more details.
  \item Mitigate replay attacks: Encrypted SNI values must not be replayable from one 
  ClientHello to another, otherwise an attacker could use an ESNI value from a victim client
  message in its own ClientHello.
  \item Support shared and split mode: Client-facing servers which use the SNI to determine 
  the target service may not be the entity which terminates the TLS connection. ESNI should therefore
  support proxies which route TLS connections to backend or origin services. This suggests two
  possible deployment models for ESNI, referred to as shared and split mode, as described in
  \cite{ietf-tls-esni-04}.
  %\item Do not stick out: 
  %\item Proper security context: 
  %\item Split server spoofing:
\end{compactitem}
%

% \begin{figure}
% \begin{minipage}[c]{.45\textwidth}
% \center
% \includegraphics[scale=0.5]{esni_modes_shared.png}
% \end{minipage}
% \begin{minipage}[c]{.45\textwidth}
% \center
% \includegraphics[scale=0.5]{esni_modes_split.png}
% \end{minipage}
% \caption{fig:modes}
% \label{Left: shared mode. Right: split mode.}
% \end{figure}

\subsection{Security and Privacy Goals} \label{sec:security}
ESNI assumes a standard active and on-path Dolev-Yao attacker that can arbitrarily drop, tamper, 
replay, and forward messages from clients. Fundamentally, a TLS handshake that negotiates ESNI should 
leak no more information than one which did not negotiate ESNI in the presence of this adversary. 
This means there are at least two necessary requirements for ESNI:
%
\begin{enumerate}
  \item SNI agreement: A successful TLS handshake implies agreement on the SNI transmitted. This means, among 
  other things, that the client authenticated the server's certificate using the SNI, and that both client and 
  server share the same view of the SNI negotiated.
  \item SNI privacy: A successful TLS handshake that negotiates ESNI does so without leaking any information 
  about the underlying SNI. Moreover, the SNI is known only to the client and server (or any recipient of the
  private ESNI key). We do not require forward secrecy for the SNI encryption.
\end{enumerate}
%
We may optionally want to hide the fact that ESNI was negotiated, as per the ``do not stick out'' goal. However, 
this is primarily only deployment concern. Furthermore, we may also want to hide the fact that a client offered
ESNI in its handshake. This may be useful for clients that wish to GREASE \cite{XXX} the extension.

\subsection{Draft-04 Design Overview and Known Attacks} \label{sec:known-attacks}
Figure \ref{fig:draft4} shows the ESNI design in draft-04 of the protocol. 

\begin{figure}[th!]
\begin{center}
\resizebox{0.8\columnwidth}{!}{\begin{msc}{}
  \drawframe{none}
  \setlength{\topheaddist}{0cm}
  \setlength{\instdist}{8.5cm}
  \setlength{\instwidth}{1.75cm}
  \declinst{cl}{}{Client $C$}
  \declinst{sr}{}{Server $S$}
  \action*{$\mathit{Knows}\ \sni, \ksni, \psk$}{cl}
  \action*{$\mathit{Knows}\ \ksnipriv, (\skp{S},\pkp{S}), \psk$}{sr}
  \nextlevel[2]
  \nextlevel
  \mess{\emph{Client Flight} ($S, g^x, \mathsf{Enc}(K_s, (r, \sni))$)}{cl}{sr}
  \nextlevel[2]
  \action*{\laction{Derive Keys:}{
    ss = \dh{g^y}{g^x} \\
    k = \kdfcontext{ss}{"esni"}}}{sr}
  \nextlevel[5]
  \mess{\emph{Server Flight} ($g^y,\mathsf{enc}(k, r)$)}{sr}{cl}
  \nextlevel
  \action*{\laction{Derive ESNI Keys:}{
    ss = \dh{g^x}{g^y} \\
    k = \kdfcontext{ss}{"esni"}}}{cl}
  \nextlevel[3]
  \end{msc}
}
\end{center}
\caption{Simple ESNI Protocol without resumption or HelloRetryRequest support.}
\label{fig:draft4}
\end{figure}

Early versions of ESNI did not achieve the desired security and privacy goals. 
For example, the first version was vulnerable to a certificate-based 
client reaction attack shown in Figure \ref{fig:attack1-client-reaction}. The SNI leak
occurs if clients processed the certificate message before verifying the CertificateVerify
signature. Specifically, if clients abort upon SNI mismatch between what they sent
and what was received in the certificate, an attacker attempt to MITM an ESNI connection
with a certificate of its choosing and try to learn the client's SNI.
The core problem was that servers did not signal to clients whether or not they processed 
the ESNI extension. Adding a nonce to the server's response implicitly authenticates
that the server processed the SNI.

\begin{figure}[th!]
\begin{center}
\resizebox{0.8\columnwidth}{!}{\begin{msc}{}
  \drawframe{none}
  \setlength{\topheaddist}{0cm}
  \setlength{\instdist}{8.5cm}
  \setlength{\instwidth}{1.75cm}
  \declinst{cl}{}{Client $C$}
  \declinst{sr}{}{Server $S$}
  \action*{$\mathit{Knows}\ \sni, \ksni$}{cl}
  \action*{$\mathit{Knows}\ \ksnipriv, (\skp{S},\pkp{S})$}{sr}
  \nextlevel[2]
  \nextlevel
  \mess{\emph{Client Flight} ($S, g^x, \mathsf{Enc}(K_s, \sni)$)}{cl}{sr}
  \nextlevel[2]
  \mess{\emph{Server Flight} ($g^y,\mathsf{enc}(k, \cert, ...), $)}{sr}{cl}
  \nextlevel
  \action*{\laction{Check SNI:}{
    \text{Abort if } \sni \text{ does not match } \cert}}{cl}
  \nextlevel[3]
  \end{msc}
}
\end{center}
\caption{Simple ESNI Protocol without resumption or HelloRetryRequest support.}
\label{fig:draft4}
\end{figure}
%

Despite this fix, draft-04 of ESNI does not achieve the necessary requirements stated above. We
describe some more attacks on ESNI deployment configurations and the protocol below.

\textbf{Probing Attacks}. If an operator partitions its servers based on SNI-specific values observable
on the wire, such as supported ciphersuites, key exchange algorithms, or application-layer protocols,
an adversary can use these differences to learn information about the client's SNI.

\textbf{HelloRetryRequest Mix and Match}. In the event of a HelloRetryRequest, clients send a fresh
key share and ESNI extension in the second ClientHello. Servers are expected to use the ESNI value
from the same ClientHello from which it received the client key shares. However, a server may use
mix and match these values, e.g., by selecting the ESNI value from the first ClientHello and the key
shares from the second ClientHello.\footnote{This is not entirely farfetched, as some operators must
process the SNI upon the first ClientHello in order to determine HelloRetryRequest parameters such
as supported ciphersuites.} This allows an on-path adversary to hijack a HelloRetryRequest, send a
second ClientHello with its own key shares, and then successfully decrypt the server flight to learn
the certificate.

\textbf{Server Ticket Reaction Attacks}. The ESNI contents are not fully bound to the entire 
ClientHello in draft-04. This means a ClientHello with ESNI \emph{and} no resumption PSK can be 
intercepted by an on-path adversary, who then attaches a ticket and PSK binder of its choosing,
and forwards the result to the original target server. If servers check whether or not the SNI
obtained from the ESNI value and the ticket match and change behavior accordingly, e.g.,
by aborting the connection, this introduces an oracle for adversaries to learn information about
client SNIs.

In general, the problems above seem to stem from the same problems: (1) ESNI contents are not
fully bound to the ClientHello, and (2) ESNI contents are not fully bound to the rest of the TLS
handshake. In the following section, we describe an ideal ESNI protocol that addresses these
shortcomings.

\section{Core Protocol} % Basic anonymous DH model (handshake secret integrity)

At its core, ESNI is a protocol between a client and server that works as described in
Figure \ref{fig:simple-esni}. It aims to provide the following guarantees:
%
\begin{itemize}
  \item Client: TLS handshake secret known by entity which has the private handshake key share (y), corresponding PSK,
  private ESNI decryption key, and ENSI nonce. 
  \item Server: TLS handshake secret known by entity which has the private handshake key share (x), corresponding PSK,
  and ENSI nonce.
  \item Client and server both agree on the same TLS handshake secret and transcript.
\end{itemize}
%

Thus, the core protocol only models the handshake up to the point of certificate receipt. It does
not capture the full TLS handshake. 

For presentation purposes, the core protocol uses the following helper routine:
%
\begin{center}
\fbox{
\procedure{$\mathsf{DeriveESNIKeys}(Zx)$}{%
  ek = \kdfcontext{zx}{\esnikey} \\
  eiv = \kdfcontext{zx}{\esniiv} \\
  ebk = \kdfcontext{zx}{\esnibinder} \\
  r = \kdfcontext{zx}{\esninonce} \\
  \pcreturn ek, eiv, ebk, r}
}
\end{center}
%
{\sf Seal} and {\sf Open} are AEAD encryption and decryption functions, respectively.

% \begin{center}
% \fbox{
% \begin{minipage}[c]{.45\textwidth}
% \procedure{$\mathsf{ClientESNIKeys}(Zx)$}{%
%   ek = \kdfcontext{zx}{``esni key''} \\
%   eiv = \kdfcontext{zx}{``esni iv''} \\
%   ebk = \kdfcontext{zx}{``esni binder''} \\
%   r = \kdfcontext{zx}{``esni nonce''} \\
%   \pcreturn ek, eiv, ebk, r}
% \end{minipage}}%
% \hfill
% \fbox{%
% \begin{minipage}[c]{.45\textwidth}
% \procedure{$\mathsf{ServerESNIKeys}(Zx)$}{%
%   ek = \kdfcontext{zx}{``esni key''} \\
%   eiv = \kdfcontext{zx}{``esni iv''} \\
%   ebk = \kdfcontext{zx}{``esni binder''} \\
%   r = \kdfcontext{zx}{``esni nonce''} \\
%   \pcreturn ek, eiv, ebk, r}
% \end{minipage}}
% \end{center}

\begin{figure}[th!]
\begin{center}
\resizebox{0.8\columnwidth}{!}{\begin{msc}{}
  \drawframe{none}
  \setlength{\topheaddist}{0cm}
  \setlength{\instdist}{8.5cm}
  \setlength{\instwidth}{1.75cm}
  \declinst{cl}{}{Client $C$}
  \declinst{sr}{}{Server $S$}
  \action*{$\mathit{Knows}\ \sni, \ksni$}{cl}
  \action*{$\mathit{Knows}\ \ksnipriv, (\skp{S},\pkp{S})$}{sr}
  \nextlevel[2]
  \action*{\laction{Computes:}{
    c \gets \Zp \\
    Zx = \dh{g^c}{\ksni} \\
    ek, eiv, ebk, r = \mathsf{DeriveESNIKeys}(Zx) \\
    \mathsf{CH} = (g^x, g^c, S, esni = \mathsf{Seal}(ek, eiv, (r, \sni)), \mathsf{Bind}(ebk, .))}}{cl}
  \nextlevel[6]
  \mess{$\mathsf{CH}$}{cl}{sr}
  \nextlevel[2]
  \action*{\laction{Computes:}{
    Zx = \dh{\ksni}{\ksnipriv} \\
    ek, eiv, ebk, r = \mathsf{DeriveESNIKeys}(Zx) \\
    (r', \sni') = \mathsf{Open}(ek, eiv, esni)}}{sr}
  \nextlevel[6]
  \action*{\laction{Verifies:}{
    \mathsf{Verify}(ebk, \mathsf{CH}) \\ 
    ss = \dh{g^y}{g^x} \\
    k' = \kdfpair{ss}{r} \\
    k = \kdfcontext{k'}{\mathtt{'handshake secret'}} \\
    \mathsf{SH} = g^y, \mathsf{Cert} = \mathsf{Seal}(k, \cert(\sni))}}{sr}
  \nextlevel[8]
  \mess{$\mathsf{SH}, \mathsf{Cert}$}{sr}{cl}
  \nextlevel
  \action*{\laction{Verifies:}{
    ss = \dh{g^x}{g^y} \\
    k' = \kdfpair{ss}{r} \\
    k = \kdfcontext{ss}{\mathtt{'handshake secret'}} \\ 
    \cert'(\sni') = \mathsf{Open}(k, \mathsf{Cert}) \\
    \mathsf{Equal}(\sni', \sni)}}{cl}
  \nextlevel[5]
  \end{msc}
}
\end{center}
\caption{Minimal Core ESNI Protocol. No resumption or HelloRetryRequest support.}
\label{fig:simple-esni}
\end{figure}

Moreover, these guarantees must hold for all TLS handshake patterns, including: normal handshakes,
resumption handshakes, and HelloRetryRequest handshakes. Considering the full variant, there are 
five secrets that influence the handshake: private signing key $sk_s$, secret Diffie Hellman key shares $(x, y)$,
pre-shared key(s) $\mathsf{psk}$, ESNI decryption key ($s$), and the ESNI nonce $r$. Informally, we require that
these values endorse each other in order to avoid the attacks described in Section \ref{sec:known-attacks}.

For example, consider the ticket-based server reaction attack, wherein the ESNI nonce is not bound 
to a ClientHello PSK. This leads to a situation wherein a server receives a ClientHello with an 
attacker-controlled PSK meant for one SNI, yet an ESNI carrying an encryption of a different SNI. 
If said server then \emph{checks} that these SNIs for equality and reacts differently in response, 
the SNI value may leak. However, if these values are properly bound, then such a check will not 
possible yield a negative answer (for honestly generated ClientHello messages), and therefore the 
reaction attack vanishes.

\subsection{Necessary Properties}

Joint binding of these secrets yields the following properties:
%
\begin{itemize}
  \item Backward binding: ESNI contents are bound to the entire ClientHello such that any modification
  is detectable by servers. ESNI contents are \emph{backward bound} to a ClientHello if it is not possible 
  to modify a CH in any way without causing an ESNI check to fail.
  \item Forward binding: TLS handshake secrets are bound to the ESNI contents such that knowledge of both
  ESNI secret(s) and one of the TLS key shares is needed to derive the handshake secrets. ESNI is \emph{forward
  bound} if it is not possible to learn the TLS handshake secret without both the Diffie Hellman shared secret and 
  ESNI shared secret.
\end{itemize}
%
As a consequence of forward binding and the need to interoperate with ESNI-incapable servers, we also require 
a signalling mechanism for clients to determine whether or not the ESNI contents were used to protect the 
handshake secret. (Trial decryption is always an option, though other more practical solutions exist.)

Beyond these critical properties, it must also be the case that observable information, which includes 
messages sent on the wire and the \emph{actions} of clients and servers using ESNI, does not leak information
about the SNI. Indeed, the reaction attack described above was due in part to such an information 
leak.\footnote{Fortunately, joint binding resolved the problem by removing a branch in the way servers
handle ClientHello messages.} We must capture this notion of information indistinguishability for completeness.
We do so via \emph{message indistinguishability} and \emph{action indistinguishability}. Informally, message 
indistinguishability means that all messages written on the wire do not vary based on SNI. Similarly, action
indistinguishability means that all node behavior as observed by \adv\ does not vary based on SNI (or any SNI-influenced
value used in the protocol).

\todo[inline]{add more rigorous definition of these}
\todo[inline]{describe how message indistinguishability is a property of configuration, and give the functions discussed IRL}

\subsection{Formal Model}

In this section, we present a model for ESNI based on ProVerif \cite{28,32}. ProVerif analyzes symbolic protocol
models using processes to represent entities which communicate using messages sent over public channels. Processes
can trigger security events representing attacks or critical steps of the target protocol, e.g., TLS connection establishment.
Moreover, processes can save messages in lookup tables for use later on. This is useful for storing long-term keying
material, such as ESNI and certificate private keys. 

Our ESNI model accounts for backward and forward binding. It also accounts for action indistinguishability for client
and server processes. It does not account for message indistinguishability, as this is something largely determined
by configuration. Each process begins by installing or obtaining long-term secrets used each TLS connection. These secrets
include public and private certificate signing keys, as well as ESNI keying material.

\subsubsection{Client ESNI Process}
XXX

\subsubsection{Server ESNI Process}
XXX

\section{Summary of Proposals}

There are two proposals that conform to the core ESNI protocol described above. They are
summarized below.

\textbf{ESNI Proxy Transformation}. A high level summary of this proposal is as follows:
%
\begin{itemize}
  \item Bind the ESNI contents to the entire ClientHello with an explicit transformation function
  that works as follows. Given a fully-formed ``private'' ClientHello (with the unencrypted SNI 
  value and ESNI nonce), encrypt the SNI value using the ClientHello as AAD, and output a ``public'' 
  ClientHelo with the SNI extension replaced with the ESNI extension. 
  \item Bind the ESNI contents to the handshake by choosing either the ``public'' or reconstructed
  ``private'' ClientHello to mix into the transcript. 
  \item Never send an ESNI extension in the event of HRR.
\end{itemize}
%
It has the following properties:
%
\begin{itemize}
  \item[$+$] XXX
  \item[$-$] The transcript used upon ESNI negotiation is not that which is sent over the wire. This is
  a significant deviation from the TLS 1.3 model and introduces interesting side effects, such as the
  ability of an unknown third party, e.g., a backend origin server, to complete the handshake without
  the client being aware. (This is a problem in TLS in general, as secret information can always be
  exfiltrated to another party to complete the handshake.)
  \item[$-$] Treats the handshake transcript, which is fed into the TLS key schedule as the {\tt Info}
  parameter to {\tt HKDF-Expand}, as secret information. HKDF leaks no information about this parameter
  if modelled as a random oracle or if the key is secret. More generally, PRFs have no guarantees about
  the secrecy of their inputs if the key is known. Importantly, in this proposal, an attacker
  does know the key in the event of HRR, yet the input is secret. Bellare and Lysyanskaya \cite{bellare2015symmetric}
  proved that HMAC satisfies the notion of a dualPRF, which roughly states that HMAC is a PRF if 
  either the the key or the input is secret. Thus, in practice, this should not affect security, though
  it may affect the proofs used for TLS 1.3.
\end{itemize}
%

\textbf{ESNI PSK Binders and Key Schedule Injection}. A high level summary of this proposal is as follows:
%
\begin{itemize}
  \item Bind the ESNI contents to the entire ClientHello with an explicit PSK binder, whose value is
  derived from the ESNI shared secret.
  \item Bind the ESNI contents to the handshake by mixing the derived ESNI nonce into the key schedule.
  \item Always generate and send a fresh ESNI extension, even in the event of HRR.
\end{itemize}
%
It has the following properties:
%
\begin{itemize}
  \item[$+$] Backward binding relies on existing PSK binder properties.
  \item[$-$] Forward binding requires key schedule modification.
  \item[$-$] In the event of session resumption, two binders are added to a ClientHello and both
  must be verified by the server. This goes against text in the TLS 1.3 specification \cite{rfc8446}, 
  which states that servers ``SHOULD NOT attempt to validate multiple binders.''
\end{itemize}
%

\bibliographystyle{plain}
\bibliography{references}

\end{document}

